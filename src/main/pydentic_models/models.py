from pydantic import BaseModel, Field
from typing import List, Optional
from langchain.output_parsers import ResponseSchema


class FeedbackRequest(BaseModel):
    user_id: Optional[str]
    query: str
    response: str
    rating: Optional[int]  = Field(None, ge=1, le=5, description="Rating from 1-5")
    notes: Optional[str]

class FeedbackResponse(BaseModel):
    success: bool
    message: str
    feedback_id: Optional[str]

class RAGRequest(BaseModel):
    symptoms: str
    image_path: str = None

class RAGResponse(BaseModel):
    diagnosis: str
    references: list

class DTQueryRequest(BaseModel):
    query: str
    top_k: int = 5

class DTQueryResponse(BaseModel):
    results: list
    success: bool
    message: str

from pydantic import BaseModel
from typing import List, Optional

class MChatRequest(BaseModel):
    user_id: str
    user_question: str

class MChatResponse(BaseModel):
    user_id: str = Field(description="The unique identifier for the user")
    user_question: str = Field(description="The question asked by the user")
    assistant_response: str = Field(description="The response provided by the assistant")
    source_documents: List[str] = Field(default_factory=list, description="List of source documents used for RAG")
    rag_used: bool = Field(default=False, description="Whether RAG was used for this response")
    chat_id: Optional[str] = Field(default=None, description="The unique identifier for this chat exchange")

class DiagnosisRequest(BaseModel):
    user_id: Optional[str] = None
    symptoms: str
    age: Optional[int] = None
    gender: Optional[str] = None
    medical_history: Optional[str] = None

class DiagnosisResponse(BaseModel):
    user_id: Optional[str] = None
    symptoms: str
    diagnosis: str
    possible_conditions: List[str]
    recommendations: List[str]
    confidence: float
    disclaimer: str

from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime

class ChatRequest(BaseModel):
    user_id: str = Field(..., description="Encrypted phone number used as user ID")
    user_question: str = Field(..., description="User's medical question")

class ChatResponse(BaseModel):
    user_id: str
    user_question: str
    response: str
    timestamp: Optional[datetime] = None

class SummaryRequest(BaseModel):
    user_id: str
    max_words: int = Field(500, description="Maximum words in summary")

class SummaryResponse(BaseModel):
    user_id: str
    summary: str
    timestamp: Optional[datetime] = None

class WhatsAppMessage(BaseModel):
    phone_number: str
    message: str
    timestamp: Optional[datetime] = None

class ConversationHistory(BaseModel):
    user_id: str
    conversations: List[Dict[str, Any]]
    
class ChatMessage(BaseModel):
    id: str = Field(alias="_id")
    user_id: str
    timestamp: datetime
    user_question: str
    assistant_response: str
    source_documents: List[str]
    rag_used: bool
    
    class Config:
        populate_by_name = True
        json_encoders = {
            datetime: lambda dt: dt.isoformat()
        }

class ChatHistoryResponse(BaseModel):
    history: List[ChatMessage]
    
response_schemas = [
    ResponseSchema(name="answer", description="Direct, user-friendly response to the question."),
    ResponseSchema(name="suggestion", description="Optional health or safety advice."),
    ResponseSchema(name="urgency", description="Level of urgency: low, medium, or high.")
]

response_schemas_rag = [
    ResponseSchema(name="user_id", description="Unique identifier for the user."),
    ResponseSchema(name="user_question", description="The question asked by the user."),
    ResponseSchema(name="assistant_response", description="The response generated by the assistant."),
    ResponseSchema(name="source_documents", description="List of documents used as references for the response."),
    ResponseSchema(name="rag_used", description="Indicates whether Retrieval-Augmented Generation (RAG) was used.")
]